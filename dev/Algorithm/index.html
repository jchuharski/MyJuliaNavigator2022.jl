<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Docs · MyJuliaPackage.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://jchuharski.github.io/MyJuliaPackage.jl/Algorithm/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MyJuliaPackage.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Algorithm Docs</a><ul class="internal"><li><a class="tocitem" href="#Greedy"><span>Greedy</span></a></li><li><a class="tocitem" href="#Greedy-with-a-Lookahead"><span>Greedy with a Lookahead</span></a></li><li><a class="tocitem" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead"><span>Improving the Greedy Algorithm with a Lookahead</span></a></li><li><a class="tocitem" href="#Greedy-with-a-Weighted-Lookahead"><span>Greedy with a Weighted Lookahead</span></a></li><li><a class="tocitem" href="#Upper-Bound"><span>Upper Bound</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jchuharski/MyJuliaPackage.jl/blob/main/docs/src/Algorithm.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ALGORITHMS"><a class="docs-heading-anchor" href="#ALGORITHMS">ALGORITHMS</a><a id="ALGORITHMS-1"></a><a class="docs-heading-anchor-permalink" href="#ALGORITHMS" title="Permalink"></a></h1><p>This document briefly explains the algorithms that were used or taken into consideration in MyJuliaPackage to solve the problem described in the Google Hashcode 2014 competition. At the end it will explain the solution, with all separate algorithms taken into account.</p><p>Before explaining the algorithms, to save space and time, we stored our neighbors using a dictionary. ​​Each junction was stored as a key with its neighbors as values. This allowed us to find the neighbors of our junctions with time complexity O(1).</p><h2 id="Greedy"><a class="docs-heading-anchor" href="#Greedy">Greedy</a><a id="Greedy-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy" title="Permalink"></a></h2><p>To start, we will be considering a greedy algorithm. Essentially, the cars will move one street at a time, and will choose the next street based on a heuristic. In this example, said heuristic takes in all the neighbors (the streets touching our current junction) and finds which street takes the largest distance/duration from the current junction. That street then becomes the next path for our current car to take. However, it will not take that street if the time to traverse said street surpasses our time constraint. In that case, that car is now finished and does not get checked.</p><p>Of course, there must be some overlap since we have eight cars. To combat this, if every single neighbor has already been seen, then we choose the street with the shortest duration to go to next. Again, it will not take that street if the time to get to the next junction surpasses our time constraint. </p><p>This greedy algorithm will work quickly because each car only needs to look at the outgoing neighbors of its current junction. This means that the time complexity for each time step is O(E) with E being the number of streets (edges). Most junctions have only a few neighboring streets, so this is essentially a constant time complexity. </p><p>Also, at each time step we need to make a data structure of size O(E) to be able to search through our neighbors. That gives us an O(E) space complexity, but since there aren&#39;t that many streets connected to each junction the space impact is minimal. </p><h2 id="Greedy-with-a-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Lookahead">Greedy with a Lookahead</a><a id="Greedy-with-a-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Lookahead" title="Permalink"></a></h2><p>To increase the greedy algorithm’s distance covered, we can have the cars look ahead a certain number of streets to find a more optimal path. Instead of taking the next street with the largest distance/duration, we look ahead through 12 streets (time steps) to see which path will give us the largest total distance/duration covered. This sends our car to the junction that would lead us to that path. It then repeats. Again, this takes into account the time constraint and will not send a car to a path that would exceed the total time. To look ahead we use a depth forward search (DFS). We have the depth currently set as a parameter that can be specified by the person running the algorithm. It automatically uses depth 10.</p><p>There of course will be overlap again, which we will combat within our DFS. If a street has already been seen, we do not have it contribute to the total distance/duration calculated for the path. This way, the car can still take the seen street if it leads to the outcome with the largest distance/duration, but it is more likely to take unseen streets. </p><p>Of course, this algorithm will be slower and take more space than our greedy algorithm. A branching factor B is the max number of neighbors a certain junction will have. For our data, we found this value to be six. Since we are looking ahead by 12 steps, we will be taking this branching factor to the tenth. Therefore, when we are searching using our DFS we find that our upper bound of time and space complexity for each time step is O(6^12) because not every junction has six streets that are connected to it. </p><h2 id="Improving-the-Greedy-Algorithm-with-a-Lookahead"><a class="docs-heading-anchor" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead">Improving the Greedy Algorithm with a Lookahead</a><a id="Improving-the-Greedy-Algorithm-with-a-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead" title="Permalink"></a></h2><p>When running the greedy algorithm with a lookahead, we realized that many of the streets were being taken multiple times and we were leaving pockets of streets that were never taken. The cars were looking to the further streets with a very large distance/duration and trying to take the fastest path to get there. This caused it to ignore many small streets in the surrounding areas and retake previously seen streets.</p><p>Below are a few of our different approaches to solving this problem. The last section indicates our final solution which gave us our largest distance traveled.</p><h3 id="Greedy-with-a-Known-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Known-Lookahead">Greedy with a Known Lookahead</a><a id="Greedy-with-a-Known-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Known-Lookahead" title="Permalink"></a></h3><p>Our first attempt to remove this issue involved understanding that our starting junction had four possible directions that the cars could take. The last four cars all went the same direction as the first car causing many sides of the city untraversed. So, we sent two cars down each of the streets and then let them begin using the algorithm. This gave us a slightly better total distance and kept the time/space complexity the same as it was before.</p><h3 id="Greedy-with-Dijkstra’s-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-Dijkstra’s-Lookahead">Greedy with Dijkstra’s Lookahead</a><a id="Greedy-with-Dijkstra’s-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-Dijkstra’s-Lookahead" title="Permalink"></a></h3><p>We then thought that sending four cars immediately to each maximum and minimum latitude and longitude of the map would allow our cars to be spaced out much more quickly, and therefore repeat less streets. </p><p>We used the &#39;dijsktra<em>shortest</em>paths&#39; function in &#39;graphs.jl&#39; to find the shortest paths (by distance/duration) that our cars could take to get to those max/min points. This did not end up changing our total distance at all and kept the time/space complexity the same as before.</p><h3 id="Greedy-with-a-Dependent-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Dependent-Lookahead">Greedy with a Dependent Lookahead</a><a id="Greedy-with-a-Dependent-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Dependent-Lookahead" title="Permalink"></a></h3><p>Our next try involved reducing the depth of our lookahead when moving further into the map. We assumed that this would send our cars to different sides of the map, and then begin to take the streets that were less often seen. So for the first 1000 time steps (streets) we had it set to depth 10, and then for the remaining steps it was of depth 5. </p><p>This in fact made our solution worse, albeit faster (since the time steps &gt;1000 had time and space complexity O(6^5)), but it lowered our total distance by at least 100,000 m. We also considered a few different changes in depth, but each still lowered our total distance.</p><h2 id="Greedy-with-a-Weighted-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Weighted-Lookahead">Greedy with a Weighted Lookahead</a><a id="Greedy-with-a-Weighted-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Weighted-Lookahead" title="Permalink"></a></h2><p>Our final and best fix was to add weights to the depths of our search. We wanted the distance of the streets further away from our current junction to account for less in the total distance to reward taking closer streets that have not been taken (since distances traveled on previously taken streets do not contribute to the overall goal).</p><p>To do this, we multiplied the distance/duration of the street by the square root of the depth/11 (so the distance/duration of the closest street, i.e. depth 11, was weighted by (10^1/2)/11, and the distance/duration of the second closest street, i.e. depth 9, was weighted by (9^1/2)/11, and so on and so forth).</p><p>This didn’t make the solution any slower than our earlier greedy algorithm with a lookahead and it increased our distance traveled by about 500,000 m.</p><h2 id="Upper-Bound"><a class="docs-heading-anchor" href="#Upper-Bound">Upper Bound</a><a id="Upper-Bound-1"></a><a class="docs-heading-anchor-permalink" href="#Upper-Bound" title="Permalink"></a></h2><p>To find the upper bound for this problem, we need to find the total distance that could possibly be covered by all of our cars within the time limit. This number does not need to take into account feasibility since we just want an upper bound. We chose to look at three ways to solve this: the fastest streets, the longest streets, and making our own algorithm an undirected graph.</p><p>For our first idea, we simply take a list of all the streets and sort them by their distance/duration, putting those with the largest speed first. We then sum the distance and time (separately) of the streets from fastest to slowest until the summed time (plus the next street) exceeds our time limit multiplied by the number of cars. Since we considered the last street possibly taking us over the time limit and did not include it, we got a lower upper bound than without it. The summed distance of those streets is our first possible upper bound. We found this to be: 1525273m</p><p>For the second idea, we sort the streets by their distance, putting those with the longest distance first. We then sum the duration and the distance of those streets (separately) from longest to shortest until our total time duration exceeds the time limit multiplied by the number of cars. The summed distance of those streets is our second possible upper bound. In practice, this idea did not work as well. Since we are trying to maximize distance over 18000 seconds, we should be considering distance over time. </p><p>For a final idea, we would’ve used our own algorithm to make an upper bound. If we changed our graph to an undirected graph it would make the solution see more streets in a faster amount of time. We however would’ve needed to account for the fact that our algorithm does not hit the true upper bound with 54000 seconds (the original total time limit). So, we would take the difference between the distance of our algorithm and the total distance of the streets in our problem and add it to the bound we just calculated. We did not put this idea into practice, but it would likely be a lower upper bound than our past two ideas.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 10 December 2022 04:46">Saturday 10 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
