<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Docs · MyJuliaPackage.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://jchuharski.github.io/MyJuliaPackage.jl/Algorithm/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MyJuliaPackage.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Algorithm Docs</a><ul class="internal"><li><a class="tocitem" href="#Greedy"><span>Greedy</span></a></li><li><a class="tocitem" href="#Greedy-with-a-Lookahead"><span>Greedy with a Lookahead</span></a></li><li><a class="tocitem" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead"><span>Improving the Greedy Algorithm with a Lookahead</span></a></li><li class="toplevel"><a class="tocitem" href="#ADD-UPPER-BOUND-AND-OTHER-THING"><span>ADD UPPER BOUND AND OTHER THING</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jchuharski/MyJuliaPackage.jl/blob/main/docs/src/Algorithm.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ALGORITHMS"><a class="docs-heading-anchor" href="#ALGORITHMS">ALGORITHMS</a><a id="ALGORITHMS-1"></a><a class="docs-heading-anchor-permalink" href="#ALGORITHMS" title="Permalink"></a></h1><p>This document briefly explains the algorithms that were used or taken into consideration in MyJuliaPackage to solve the problem described in the Google Hashcode 2014 competition. At the end it will explain the solution at the end with all separate algorithms taken into account.</p><p>First of all, to save space and time, we stored our neighbors using a dictionary. Each junction was stored as a key with its neighbors as values. This allowed us to find the neighbors of our junctions with time complexity O(1). </p><p>Now, on with the algorithms.</p><h2 id="Greedy"><a class="docs-heading-anchor" href="#Greedy">Greedy</a><a id="Greedy-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy" title="Permalink"></a></h2><p>To start, we will be considering a greedy algorithm. Essentially, the cars will move one street at a time, and will choose the next street based on a heuristic. In this example, said heuristic takes in all the neighbors for our current junction and finds which street takes the largest distance/duration from the current junction. That then becomes the next street for our current car to take. However, it will not take that street if the time to get to that street surpasses our time constraint. </p><p>Of course, there must be some overlap since we have eight cars. To combat this, if every single neighbor (the streets touching our current junction) has already been seen, then we choose the street with the shortest distance to go to next. Again, it will not take that street if the time to get to the next junction surpasses our time constraint. </p><p>This greedy algorithm will work quickly because each car only needs to look at the outgoing neighbors of its current junction. This means that the time complexity for each time step is O(E) with E being the number of streets (edges). Most junctions have only a few neighboring streets, so this is essentially a constant time complexity. </p><p>Also, at each time step we need to make a data structure of size O(E) to be able to search through our neighbors. That gives us an O(E) space complexity, but since there aren&#39;t that many streets connected to each junction it isn’t that bad. </p><h2 id="Greedy-with-a-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Lookahead">Greedy with a Lookahead</a><a id="Greedy-with-a-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Lookahead" title="Permalink"></a></h2><p>To make the greedy algorithm better, we can have the cars look ahead a certain number of streets to find a more optimal path. Instead of taking the next street with the largest distance/duration, we look ahead through 10 streets (time steps) to see which path will give us the largest total distance/duration covered. This sends our car to the junction that would lead us to that path. It then repeats. Again, this takes into account the time constraint and will not send a car to a path that would exceed the total time. To look ahead we use a depth first search.</p><p>There of course will be overlap again, which we will combat within our DFS. If a street has already been seen, we do not have it contribute to the total distance/duration on that path. This way, it still will take the seen street if it leads us to extremely good streets, but it is more likely to take unseen streets. </p><p>Of course, this algorithm will be slower and take more space than our greedy algorithm. A branching factor B is the max number of neighbors a certain junction will have. For our data, we found this value to be six. Since we are looking ahead by 10 steps, we will be taking this branching factor to the tenth. Therefore, when we are searching using our DFS we find that our upper bound of time and space complexity for each time step is O(6^10) because not every junction has six streets that are connected to it. </p><h2 id="Improving-the-Greedy-Algorithm-with-a-Lookahead"><a class="docs-heading-anchor" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead">Improving the Greedy Algorithm with a Lookahead</a><a id="Improving-the-Greedy-Algorithm-with-a-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-the-Greedy-Algorithm-with-a-Lookahead" title="Permalink"></a></h2><p>When running the greedy algorithm with a lookahead, we realized that many of the streets were being taken multiple times and we were leaving pockets of streets that didn’t end up getting taken by cars. The cars were looking to the further very good streets and trying to take the fastest path to get there. This caused it to ignore many small streets in the surrounding areas and retake previously seen streets.</p><p>So, below are a few of our different ideas to combat this issue. The last section indicates our final solution which gave us our largest distance traveled.</p><h3 id="Greedy-with-a-Known-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-a-Known-Lookahead">Greedy with a Known Lookahead</a><a id="Greedy-with-a-Known-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-a-Known-Lookahead" title="Permalink"></a></h3><p>Our first try to stop this issue involved understanding that our starting junction had four possible directions that the cars could take. The last four cars all went the same direction as the first car causing many sides of the city to not be traversed. So, we sent two cars down each of the streets and then let them begin using the algorithm.</p><p>This gave us a slightly better total distance and kept the time/space complexity the same as it was before.</p><h3 id="Greedy-with-Dijkstra’s-Lookahead"><a class="docs-heading-anchor" href="#Greedy-with-Dijkstra’s-Lookahead">Greedy with Dijkstra’s Lookahead</a><a id="Greedy-with-Dijkstra’s-Lookahead-1"></a><a class="docs-heading-anchor-permalink" href="#Greedy-with-Dijkstra’s-Lookahead" title="Permalink"></a></h3><p>We then thought that sending four cars immediately to each maximum and minimum latitude and longitude of the map would allow our cars to be spaced out much more quickly, and therefore repeat less streets. </p><p>We used the dijsktra<em>shortest</em>paths function in graphs.jl to find the shortest paths (by distance/duration) that our cars could take to get to those max/min points. This did not end up changing our total distance at all and kept the time/space complexity the same as before.</p><h1 id="ADD-UPPER-BOUND-AND-OTHER-THING"><a class="docs-heading-anchor" href="#ADD-UPPER-BOUND-AND-OTHER-THING">ADD UPPER BOUND AND OTHER THING</a><a id="ADD-UPPER-BOUND-AND-OTHER-THING-1"></a><a class="docs-heading-anchor-permalink" href="#ADD-UPPER-BOUND-AND-OTHER-THING" title="Permalink"></a></h1></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 9 December 2022 08:05">Friday 9 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
