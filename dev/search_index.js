var documenterSearchIndex = {"docs":
[{"location":"Algorithm/#ALGORITHMS","page":"Algorithm Docs","title":"ALGORITHMS","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"This document briefly explains the algorithms that were used or taken into consideration in MyJuliaPackage to solve the problem described in the Google Hashcode 2014 competition. At the end it will explain the solution at the end with all separate algorithms taken into account.","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"First of all, to save space and time, we stored our neighbors using a dictionary. Each junction was stored as a key with its neighbors as values. This allowed us to find the neighbors of our junctions with time complexity O(1). ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"Now, on with the algorithms.","category":"page"},{"location":"Algorithm/#Greedy","page":"Algorithm Docs","title":"Greedy","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"To start, we will be considering a greedy algorithm. Essentially, the cars will move one street at a time, and will choose the next street based on a heuristic. In this example, said heuristic takes in all the neighbors for our current junction and finds which street takes the largest distance/duration from the current junction. That then becomes the next street for our current car to take. However, it will not take that street if the time to get to that street surpasses our time constraint. ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"Of course, there must be some overlap since we have eight cars. To combat this, if every single neighbor (the streets touching our current junction) has already been seen, then we choose the street with the shortest distance to go to next. Again, it will not take that street if the time to get to the next junction surpasses our time constraint. ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"This greedy algorithm will work quickly because each car only needs to look at the outgoing neighbors of its current junction. This means that the time complexity for each time step is O(E) with E being the number of streets (edges). Most junctions have only a few neighboring streets, so this is essentially a constant time complexity. ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"Also, at each time step we need to make a data structure of size O(E) to be able to search through our neighbors. That gives us an O(E) space complexity, but since there aren't that many streets connected to each junction it isn’t that bad. ","category":"page"},{"location":"Algorithm/#Greedy-with-a-Lookahead","page":"Algorithm Docs","title":"Greedy with a Lookahead","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"To make the greedy algorithm better, we can have the cars look ahead a certain number of streets to find a more optimal path. Instead of taking the next street with the largest distance/duration, we look ahead through 10 streets (time steps) to see which path will give us the largest total distance/duration covered. This sends our car to the junction that would lead us to that path. It then repeats. Again, this takes into account the time constraint and will not send a car to a path that would exceed the total time. To look ahead we use a depth first search.","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"There of course will be overlap again, which we will combat within our DFS. If a street has already been seen, we do not have it contribute to the total distance/duration on that path. This way, it still will take the seen street if it leads us to extremely good streets, but it is more likely to take unseen streets. ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"Of course, this algorithm will be slower and take more space than our greedy algorithm. A branching factor B is the max number of neighbors a certain junction will have. For our data, we found this value to be six. Since we are looking ahead by 10 steps, we will be taking this branching factor to the tenth. Therefore, when we are searching using our DFS we find that our upper bound of time and space complexity for each time step is O(6^10) because not every junction has six streets that are connected to it. ","category":"page"},{"location":"Algorithm/#Improving-the-Greedy-Algorithm-with-a-Lookahead","page":"Algorithm Docs","title":"Improving the Greedy Algorithm with a Lookahead","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"When running the greedy algorithm with a lookahead, we realized that many of the streets were being taken multiple times and we were leaving pockets of streets that didn’t end up getting taken by cars. The cars were looking to the further very good streets and trying to take the fastest path to get there. This caused it to ignore many small streets in the surrounding areas and retake previously seen streets.","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"So, below are a few of our different ideas to combat this issue. The last section indicates our final solution which gave us our largest distance traveled.","category":"page"},{"location":"Algorithm/#Greedy-with-a-Known-Lookahead","page":"Algorithm Docs","title":"Greedy with a Known Lookahead","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"Our first try to stop this issue involved understanding that our starting junction had four possible directions that the cars could take. The last four cars all went the same direction as the first car causing many sides of the city to not be traversed. So, we sent two cars down each of the streets and then let them begin using the algorithm.","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"This gave us a slightly better total distance and kept the time/space complexity the same as it was before.","category":"page"},{"location":"Algorithm/#Greedy-with-Dijkstra’s-Lookahead","page":"Algorithm Docs","title":"Greedy with Dijkstra’s Lookahead","text":"","category":"section"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"We then thought that sending four cars immediately to each maximum and minimum latitude and longitude of the map would allow our cars to be spaced out much more quickly, and therefore repeat less streets. ","category":"page"},{"location":"Algorithm/","page":"Algorithm Docs","title":"Algorithm Docs","text":"We used the dijsktrashortestpaths function in graphs.jl to find the shortest paths (by distance/duration) that our cars could take to get to those max/min points. This did not end up changing our total distance at all and kept the time/space complexity the same as before.","category":"page"},{"location":"Algorithm/#ADD-UPPER-BOUND-AND-OTHER-THING","page":"Algorithm Docs","title":"ADD UPPER BOUND AND OTHER THING","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MyJuliaPackage","category":"page"},{"location":"#MyJuliaPackage","page":"Home","title":"MyJuliaPackage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MyJuliaPackage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MyJuliaPackage]","category":"page"},{"location":"#MyJuliaPackage.create_graph-Tuple{HashCode2014.City}","page":"Home","title":"MyJuliaPackage.create_graph","text":"Creates our own graph instance so that we don't have to recompute things so many times. :)\n\n\n\n\n\n","category":"method"},{"location":"#MyJuliaPackage.explorer_1d-Tuple{Any, Any, Any}","page":"Home","title":"MyJuliaPackage.explorer_1d","text":"Base case for the recursion explorer. Checks just the best distance/duration in the set of streets we haven't traversed. :)\n\n\n\n\n\n","category":"method"},{"location":"#MyJuliaPackage.explorer_nd-NTuple{5, Any}","page":"Home","title":"MyJuliaPackage.explorer_nd","text":"Explores arbitrary depth of the graph using recursion. Sums distance/duration to get the best overall speed. :)\n\n\n\n\n\n","category":"method"},{"location":"#MyJuliaPackage.gred-Tuple{HashCode2014.City}","page":"Home","title":"MyJuliaPackage.gred","text":"Greedy search approach to returning Solution. Uses depth forward search to determine a greedy choice. :)\n\n\n\n\n\n","category":"method"},{"location":"#MyJuliaPackage.lowest_dur_neighbor-Tuple{Any}","page":"Home","title":"MyJuliaPackage.lowest_dur_neighbor","text":"Returns the neighboring (end, duration, distance) tuple with the lowest duration. :)\n\n\n\n\n\n","category":"method"},{"location":"#MyJuliaPackage.total_distance-Tuple{Any, Any}","page":"Home","title":"MyJuliaPackage.total_distance","text":"Returns the total distance of an array of itineraries\n\n\n\n\n\n","category":"method"}]
}
